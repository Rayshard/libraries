☐ json
    ☐ README
    ☐ add unicode support
☐ c++:lpc
    ☐ add tests
    ☐ Change ParseError to inherit from std::exception and override the what func
        ☐ This will allow you to store a 'trace' in an excpetion
    ☐ Add Parser<T>.Satisfty(bool(*_predicate)(const Result&)) to parser: succeeds if predicate is true, fails if predicatte is fails
    ☐ Add Parser<bool>.Test(T _value) to parser: always succeeds, returning a parseresult with value true if parser succeeds with valkue _value
    ☐ Add Parser<std::monostate> Not(Parser<T> _parser): succeeds if _parser fails
    ☐ Add Parser<std::monostate> Error(std::string messgae): always fails and uses message and ParseError Message
    ☐ Add Count(parser, n) = Quantified(parser, min=n, max=n)
    ☐ Between(open, parser, close) = open >> parser << close
    ☐ Chain(parser, op, min, max) op:pair<parser, Left or Right assosiative>
    ☐ Chain(parser, vector<ops>)
    ☐ Suffixed(parser, suffix) = parser << suffix
    ☐ Prefixed(prefix, parser) = prefix >> suffix
    ☐ LookAhead(parser): parsers parse but goes bback to original stream position
    ☐ Regex()
        ☐ Char()
        ☐ Chars()
        ☐ EOS()
        ☐ AnyChar()
        ☐ Letters()
        ☐ Digits()
        ☐ AlphaNum()

☐ unittest
    ☐ README

☐ Future Libraries
    ☐ tokenizer and parser
    ☐ cli